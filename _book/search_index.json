[
["index.html", "Learn RDataTable CoverPage", " Learn RDataTable Vikram Singh Rawat 2019-07-21 CoverPage R is Already a Slow Language please don’t defame it by using even slower packages. "],
["intro.html", "Chapter 1 Introduction", " Chapter 1 Introduction I seem to recall that we were targetting 512k Macintoshes. In our dreams we might have seen 16Mb Sun. — Ross Ihaka (in reply to the question whether R&amp;R thought when they started out that they would see R using 16G memory on a dual Opteron computer) R-help (November 2003) There is a reason open source is successful. That is something one can not do can be done by someone else. It gives you a thousand hands to work on a task and a million eyes to look over it. data.table is an excellent example of such a task which helped people handle data smoothly. It is an Excellent package for manupulating data efficiently. It is written in one of the most low level languages out there; C to use memory and cores more efficiently. as of 2019 Many people look after the package day and night. It’s tried and tested and you shouldn’t have any problem using it in production at all. In this book we will try to teach you everything you need to know about using data.table package in R. If you are wondering, and which you should; why should I learn data.table. I have 4 reasons for you. More Speed Less Memory Few KeyStrokes Easy Syntax NOTE : From now on we will use Rdatatable and the package data.table interchangebly. "],
["speed.html", "Chapter 2 Speed", " Chapter 2 Speed You are officially a programmer the day you have learned basics of R programming. People will expect you to know programming concepts And It will all come naturally to you over time. Please Watch this video before reading anything else. It’s a must watch video for anybody trying to learn programming. Data.table is the fastest package in R. There is no doubt about it. Everybody in R knows this fact and respect it. Even Pandas doesn’t stand a chance against data.table. If you really want to see the power of this package you should definetly click here to see benchmarks. It is the most comprehensive benchmark on almost all the packages in all the languages from R to python and even julia. This is something I always show to my friends who tell me python is faster than R. a preview of benchmarks In R people are constantly told that saving a few miliseconds is no good. But if you use a package that save a few miliseconds on every (shft + enter) you press. And you use R everyday for a few years. How many hours will you save simple by switching to a different package. I don’t want to hypothetically calculate it but hope you get the picture. And to top it off your code is almost always ready for production. Because it will be the fastest. That will help especially when you want to create a shiny app or a plumber API. As a programmer you should be able to utilize full resources of a computer. "],
["memory.html", "Chapter 3 Memory 3.1 Pure function 3.2 Impure functions 3.3 Pass by value 3.4 Pass by reference", " Chapter 3 Memory Before we understand memory imprint in R. Lets start with a basic concept in functional programming. Pure function Impure function. 3.1 Pure function Any function that doesn’t change the state of all objects in R and return the same value are called pure function. sqrt(2) ## [1] 1.414214 log(2) ## [1] 0.6931472 names(mtcars) ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; functions like these are called pure function. They don’t change anything at all and They return the same output given same input. 3.2 Impure functions And everything else is impure function. Functions like : rnorm(2) ## [1] -0.08340992 -0.22842758 library(data.table) plot(mtcars) library will load data.table or any package in R and then you can use it afterwards so it does change the current state of R and Plotting is impure for same reason. While rnorm will produce different result on same input every time. All these functions Either don’t give same output on same input or change the global environment in some way. This is crucial in understanding the next concept. There are 2 ways an element can be passed in a function. pass by value pass by reference 3.3 Pass by value Most of the function in R use pass by value. almost all the function in base R use pass by value. Where you create a copy of the object pass it in a function and then return the value out of it. for example read this code. a &lt;- mtcars b &lt;- function(a){ a &lt;- a[1,] return(a) } b(a) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 But it didn’t change the actual a head(a) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 in order to change the actual value of a we will have to pass it in a like this. a &lt;- b(a) a ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 now the a has been change permanently. 3.4 Pass by reference When you work on huge passing by value could sometime crash your programme. Thus data.table provide pass by reference in almost all of it’s functions. a &lt;- mtcars setDT(a) setnames(x = a, old = names(a), new = toupper(names(a))) a[, b:= character(.N) ] head(a) ## MPG CYL DISP HP DRAT WT QSEC VS AM GEAR CARB b ## 1: 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2: 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3: 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4: 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5: 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6: 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 I have a constantly in the previous example. converted a from a data.frame to data.table changed all the names from lowercase to uppercase. added a new empty character column in a and never in any of the statement have I used the assignment operator. These techniques are very beneficial when will learn about them later in other chapters. For the time being you must understand that data.table provides you an alternative to use your memory more effeciently. "],
["keystrokes.html", "Chapter 4 Keystrokes", " Chapter 4 Keystrokes "],
["syntax.html", "Chapter 5 Syntax", " Chapter 5 Syntax "],
["from1.html", "Chapter 6 From", " Chapter 6 From "],
["where1.html", "Chapter 7 Where", " Chapter 7 Where "],
["select1.html", "Chapter 8 Select", " Chapter 8 Select "],
["group1.html", "Chapter 9 Group By", " Chapter 9 Group By "],
["from2.html", "Chapter 10 From", " Chapter 10 From "],
["where2.html", "Chapter 11 Where", " Chapter 11 Where "],
["select2.html", "Chapter 12 Select", " Chapter 12 Select "],
["group2.html", "Chapter 13 Group By", " Chapter 13 Group By "],
["update.html", "Chapter 14 Update", " Chapter 14 Update "],
["addcolumn.html", "Chapter 15 Add Column", " Chapter 15 Add Column "],
["append.html", "Chapter 16 Append", " Chapter 16 Append "],
["join.html", "Chapter 17 Join", " Chapter 17 Join "],
["melt.html", "Chapter 18 Melt", " Chapter 18 Melt "],
["cast.html", "Chapter 19 Dcast", " Chapter 19 Dcast "],
["split.html", "Chapter 20 tstrsplit", " Chapter 20 tstrsplit "],
["sd.html", "Chapter 21 .SD", " Chapter 21 .SD "],
["sdcols.html", "Chapter 22 .SDcols", " Chapter 22 .SDcols "],
["later.html", "Chapter 23 Delayed calculation {}", " Chapter 23 Delayed calculation {} "],
["set.html", "Chapter 24 setFunctions", " Chapter 24 setFunctions "],
["date.html", "Chapter 25 IDate", " Chapter 25 IDate "],
["time.html", "Chapter 26 ITime", " Chapter 26 ITime "]
]
