[
["index.html", "Learn RDataTable CoverPage", " Learn RDataTable Vikram Singh Rawat 2019-07-22 CoverPage R is Already a Slow Language please don’t defame it by using even slower packages. "],
["intro.html", "Chapter 1 Introduction", " Chapter 1 Introduction I seem to recall that we were targetting 512k Macintoshes. In our dreams we might have seen 16Mb Sun. — Ross Ihaka (in reply to the question whether R&amp;R thought when they started out that they would see R using 16G memory on a dual Opteron computer) R-help (November 2003) There is a reason open source is successful. That is something one can not do can be done by someone else. It gives you a thousand hands to work on a task and a million eyes to look over it. data.table is an excellent example of such a task which helped people handle data smoothly. It is an Excellent package for manupulating data efficiently. It is written in one of the most low level languages out there; C to use memory and cores more efficiently. as of 2019 Many people look after the package day and night. It’s tried and tested and you shouldn’t have any problem using it in production at all. In this book we will try to teach you everything you need to know about using data.table package in R. If you are wondering, and which you should; why should I learn data.table. I have 4 reasons for you. More Speed Less Memory Few KeyStrokes Easy Syntax NOTE : From now on we will use Rdatatable and the package data.table interchangebly. "],
["speed.html", "Chapter 2 Speed", " Chapter 2 Speed You are officially a programmer the day you have learned basics of R programming. People will expect you to know programming concepts And It will all come naturally to you over time. Please Watch this video before reading anything else. It’s a must watch video for anybody trying to learn programming. Data.table is the fastest package in R. There is no doubt about it. Everybody in R knows this fact and respect it. Even Pandas doesn’t stand a chance against data.table. If you really want to see the power of this package you should definetly click here to see benchmarks. It is the most comprehensive benchmark on almost all the packages in all the languages from R to python and even julia. This is something I always show to my friends who tell me python is faster than R. a preview of benchmarks In R people are constantly told that saving a few miliseconds is no good. But if you use a package that save a few miliseconds on every (shft + enter) you press. And you use R everyday for a few years. How many hours will you save simple by switching to a different package. I don’t want to hypothetically calculate it but hope you get the picture. And to top it off your code is almost always ready for production. Because it will be the fastest. That will help especially when you want to create a shiny app or a plumber API. As a programmer you should be able to utilize full resources of a computer. "],
["memory.html", "Chapter 3 Memory 3.1 Pure function 3.2 Impure functions 3.3 Pass by value 3.4 Pass by reference", " Chapter 3 Memory Before we understand memory imprint in R. Lets start with a basic concept in functional programming. Pure function Impure function. 3.1 Pure function Any function that doesn’t change the state of all objects in R and return the same value are called pure function. sqrt(2) ## [1] 1.414214 log(2) ## [1] 0.6931472 names(mtcars) ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; functions like these are called pure function. They don’t change anything at all and They return the same output given same input. 3.2 Impure functions And everything else is impure function. Functions like : rnorm(2) ## [1] -0.659133 1.674476 library(data.table) plot(mtcars) library will load data.table or any package in R and then you can use it afterwards so it does change the current state of R and Plotting is impure for same reason. While rnorm will produce different result on same input every time. All these functions Either don’t give same output on same input or change the global environment in some way. This is crucial in understanding the next concept. There are 2 ways an element can be passed in a function. pass by value pass by reference 3.3 Pass by value Most of the function in R use pass by value. almost all the function in base R use pass by value. Where you create a copy of the object pass it in a function and then return the value out of it. for example read this code. a &lt;- mtcars b &lt;- function(a){ a &lt;- a[1,] return(a) } b(a) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 But it didn’t change the actual a head(a) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 in order to change the actual value of a we will have to pass it in a like this. a &lt;- b(a) a ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 now the a has been change permanently. 3.4 Pass by reference When you work on huge passing by value could sometime crash your programme. Thus data.table provide pass by reference in almost all of it’s functions. a &lt;- mtcars setDT(a) setnames(x = a, old = names(a), new = toupper(names(a))) a[, b:= character(.N) ] head(a) ## MPG CYL DISP HP DRAT WT QSEC VS AM GEAR CARB b ## 1: 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2: 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3: 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4: 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5: 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6: 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 I have a constantly in the previous example. converted a from a data.frame to data.table changed all the names from lowercase to uppercase. added a new empty character column in a and never in any of the statement have I used the assignment operator. These techniques are very beneficial when will learn about them later in other chapters. For the time being you must understand that data.table provides you an alternative to use your memory more effeciently. "],
["keystrokes.html", "Chapter 4 Keystrokes", " Chapter 4 Keystrokes This is a highly controversial topic. People could regard that as a disadvantage as well. But I beg to differ because once you understand a syntax very well you don’t need an explaination of it ever again. Most common of these function are lm(), rnorm(), &lt;-, == etc… from base R. You use these syntax everyday without ever looking for documentation for these functions. Because I am sure you have learned them pretty well. But they are nothing more than just plain symbols. Take for example If I ask you to add 3 4 times using \\(3+3+3+3\\) or multiply 3 4 times using \\(3\\times3\\times3\\times3\\) you would be frustrated while \\(3\\times4\\) and \\(3^4\\) is much more consise. Same logic for is far more understandable. Symbols like \\(\\sum|\\int|\\ln|\\pi|\\) can take some time to understand but will help explain complex ideas easily later on. data.table has a very clear and consise syntax. For example: group by is optional select arguement is optional you don’t have to decide arguement names .SD == Subset of Data .SDcols == cols to be chosen for .SD .() == list() := == update or append data “:=” == multiple updates in a data Automatic conversion of list into columns like : mtcars %&gt;% lapply(function(x){ as.integer(x)}) ## $mpg ## [1] 21 21 22 21 18 18 14 24 22 19 17 16 17 15 10 10 14 32 30 33 21 15 15 ## [24] 13 19 27 26 30 15 19 15 21 ## ## $cyl ## [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4 ## ## $disp ## [1] 160 160 108 258 360 225 360 146 140 167 167 275 275 275 472 460 440 ## [18] 78 75 71 120 318 304 350 400 79 120 95 351 145 301 121 ## ## $hp ## [1] 110 110 93 110 175 105 245 62 95 123 123 180 180 180 205 215 230 ## [18] 66 52 65 97 150 150 245 175 66 91 113 264 175 335 109 ## ## $drat ## [1] 3 3 3 3 3 2 3 3 3 3 3 3 3 3 2 3 3 4 4 4 3 2 3 3 3 4 4 3 4 3 3 4 ## ## $wt ## [1] 2 2 2 3 3 3 3 3 3 3 3 4 3 3 5 5 5 2 1 1 2 3 3 3 3 1 2 1 3 2 3 2 ## ## $qsec ## [1] 16 17 18 19 17 20 15 20 22 18 18 17 17 18 17 17 17 19 18 19 20 16 17 ## [24] 15 17 18 16 16 14 15 14 18 ## ## $vs ## [1] 0 0 1 1 0 1 0 1 1 1 1 0 0 0 0 0 0 1 1 1 1 0 0 0 0 1 0 1 0 0 0 1 ## ## $am ## [1] 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 ## ## $gear ## [1] 4 4 4 3 3 3 3 4 4 4 4 3 3 3 3 3 3 4 4 4 3 3 3 3 3 4 5 5 5 5 5 4 ## ## $carb ## [1] 4 4 1 1 2 1 4 2 2 4 4 3 3 3 4 4 4 1 2 1 1 2 2 4 2 1 2 2 4 6 8 2 Here it will return a list of vectors mt &lt;- data.table(mtcars) mt[,lapply(.SD,function(x){ as.integer(x)})] ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1: 21 6 160 110 3 2 16 0 1 4 4 ## 2: 21 6 160 110 3 2 17 0 1 4 4 ## 3: 22 4 108 93 3 2 18 1 1 4 1 ## 4: 21 6 258 110 3 3 19 1 0 3 1 ## 5: 18 8 360 175 3 3 17 0 0 3 2 ## 6: 18 6 225 105 2 3 20 1 0 3 1 ## 7: 14 8 360 245 3 3 15 0 0 3 4 ## 8: 24 4 146 62 3 3 20 1 0 4 2 ## 9: 22 4 140 95 3 3 22 1 0 4 2 ## 10: 19 6 167 123 3 3 18 1 0 4 4 ## 11: 17 6 167 123 3 3 18 1 0 4 4 ## 12: 16 8 275 180 3 4 17 0 0 3 3 ## 13: 17 8 275 180 3 3 17 0 0 3 3 ## 14: 15 8 275 180 3 3 18 0 0 3 3 ## 15: 10 8 472 205 2 5 17 0 0 3 4 ## 16: 10 8 460 215 3 5 17 0 0 3 4 ## 17: 14 8 440 230 3 5 17 0 0 3 4 ## 18: 32 4 78 66 4 2 19 1 1 4 1 ## 19: 30 4 75 52 4 1 18 1 1 4 2 ## 20: 33 4 71 65 4 1 19 1 1 4 1 ## 21: 21 4 120 97 3 2 20 1 0 3 1 ## 22: 15 8 318 150 2 3 16 0 0 3 2 ## 23: 15 8 304 150 3 3 17 0 0 3 2 ## 24: 13 8 350 245 3 3 15 0 0 3 4 ## 25: 19 8 400 175 3 3 17 0 0 3 2 ## 26: 27 4 79 66 4 1 18 1 1 4 1 ## 27: 26 4 120 91 4 2 16 0 1 5 2 ## 28: 30 4 95 113 3 1 16 1 1 5 2 ## 29: 15 8 351 264 4 3 14 0 1 5 4 ## 30: 19 6 145 175 3 2 15 0 1 5 6 ## 31: 15 8 301 335 3 3 14 0 1 5 8 ## 32: 21 4 121 109 4 2 18 1 1 4 2 ## mpg cyl disp hp drat wt qsec vs am gear carb While this will return a data.frame as we needed. We will explain each of these points later on in the book. For the time being just try to understand that even less keystrokes can help you a lot in EDA ( exploratory data analysis ). "],
["syntax.html", "Chapter 5 Syntax", " Chapter 5 Syntax "],
["from1.html", "Chapter 6 From", " Chapter 6 From "],
["where1.html", "Chapter 7 Where", " Chapter 7 Where "],
["select1.html", "Chapter 8 Select", " Chapter 8 Select "],
["group1.html", "Chapter 9 Group By", " Chapter 9 Group By "],
["from2.html", "Chapter 10 From", " Chapter 10 From "],
["where2.html", "Chapter 11 Where", " Chapter 11 Where "],
["select2.html", "Chapter 12 Select", " Chapter 12 Select "],
["group2.html", "Chapter 13 Group By", " Chapter 13 Group By "],
["update.html", "Chapter 14 Update", " Chapter 14 Update "],
["addcolumn.html", "Chapter 15 Add Column", " Chapter 15 Add Column "],
["append.html", "Chapter 16 Append", " Chapter 16 Append "],
["join.html", "Chapter 17 Join", " Chapter 17 Join "],
["melt.html", "Chapter 18 Melt", " Chapter 18 Melt "],
["cast.html", "Chapter 19 Dcast", " Chapter 19 Dcast "],
["split.html", "Chapter 20 tstrsplit", " Chapter 20 tstrsplit "],
["sd.html", "Chapter 21 .SD", " Chapter 21 .SD "],
["sdcols.html", "Chapter 22 .SDcols", " Chapter 22 .SDcols "],
["later.html", "Chapter 23 Delayed calculation {}", " Chapter 23 Delayed calculation {} "],
["set.html", "Chapter 24 setFunctions", " Chapter 24 setFunctions "],
["date.html", "Chapter 25 IDate", " Chapter 25 IDate "],
["time.html", "Chapter 26 ITime", " Chapter 26 ITime "],
["listcol.html", "Chapter 27 List Columns", " Chapter 27 List Columns "],
["functions.html", "Chapter 28 Inside a Function", " Chapter 28 Inside a Function "]
]
